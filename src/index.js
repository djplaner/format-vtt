/**
 * Following Javascript is a conversion of Python code from
 *  https://github.com/georgiewellock/VTT_formatter/blob/master/vttformatter/vttformatter.py
 */


// default pause time suggesting separate paragraphs
const PARA_DIFF = 500;

/**
 * Return an object containing information parsed from the vtt text, 
 * including keys for
 * - messages ???
 * - duration ??? doesn't appear to be useful, only getting last duration??
 * - language ???
 * 
 * @name createVttDictionary
 * @param {String} vtt
 * @returns {Object} collection of information from vtt text
 */

function createVttDictionary(vtt) {
  // break vtt text into a sequence of lines
  let lines = vtt.split(/\r?\n/).map((string) => string.trim());

  let vttDict = {};
  vttDict["messages"] = []; 

  let index = 0;
  for (const line of lines) {
    if (line.startsWith("NOTE duration")) {
      let splitLines = line.split(':"');
      vttDict["duration"] = splitLines[1].replace('"', "").trim();

      let pattern = /[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{7}/;
      if (!vttDict["duration"].match(pattern)) {
        throw "duration not in correct format";
      }
    }
    if (line.startsWith("NOTE language")) {
      vttDict["language"] = line.split(":")[1].trim();
    }
    if (line.startsWith("NOTE Confidence")) {
      let msg = readMessage(index, lines);
      vttDict["messages"].push(msg); //, messages );
    }
    index++;
  }

  return vttDict;
}

/**
 * Return an object with attributes parsed from a single message (caption)
 * from the VTT file. Attributes include:
 * - confidence
 * - start and stop - string indicating time into video when content displayed on video
 * - marker
 * - content - actual content of the message
 * 
 * @name readMessage
 * @param {Number} i
 * @param {String} data the original vtt file text
 * @returns {Object} dictionary containing the elements of each message item
 *   Loops through the list of file lines starting at a given index until there
 *   is a line break. Taken as a message item, containing a confidence level, uuid,
 *   timestamp and content and creates a dictionary.
 */

function readMessage(i, data) {
  let message = {};

  // read each line of the message as per vtt format
  // parse relevant content and place into message object
  message["confidence"] = data[i].split(":")[1].trim();
  let pattern = /[0-1]{1}.[0-9]+/;
  if (!message["confidence"].match(pattern)) {
    throw `Confidence value ${message["confidence"]} not in correct format`;
  }
  // skip onto next lines - marker
  i += 2;

  message["marker"] = data[i].trim();
  pattern = new RegExp("[0-9a-f]{8}(?:-[0-9a-f]{4}){3}-[0-9a-f]{12}", "i");
  if (!message["marker"].match(pattern)) {
    throw "Marker not in UUID format";
  }

  // skip onto start/stop
  i += 1;
  let dSplit = data[i].split(" ");
  message["start"] = dSplit[0].trim();
  message["stop"] = dSplit[dSplit.length - 1].trim();
  pattern = /[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3}/;
  if (!message["start"].match(pattern)) {
    throw `Start time not in correct format - ${message["start"]}`;
  }
  if (!message["stop"].match(pattern)) {
    throw `Stop time not in correct format - ${message["stop"]}`;
  }

  // read all of the content until a line break (empty line)
  message["content"] = Array();
  while (i < data.length - 1 && data[i] !== "") {
    i++;
    if (data[i] !== "") {
      message["content"] = message["content"].concat(data[i].trim());
    }
  }

  return message;
}

/**
 * Return HTML of the vtt captions formatted into paragraphs. 
 * 
 * @function formatText
 * @param {Array} vttDict - dictionary generated by createVttDictionary
 * @returns {String} HTML of the vtt captions formatted into paragraphs
 */

function formatText(vttDict, pause = PARA_DIFF) {
  let part_messages = Array();
  for (const item of vttDict["messages"]) {
    part_messages = part_messages.concat(item["content"].join(" "));
  }

  let full_messages = Array();

  // arrays start and stop will contain times when each message starts stops
  const start = vttDict["messages"].map((item) => item.start); //[item['start'] for item in vttDict['messages']];
  const stop = vttDict["messages"].map((item) => item.stop); //[item['stop'] for item in vttDict['messages']];

  let i = 0;
  while (i < part_messages.length - 2) {
    // check to see if the start and stop times for subsequent messages are the same,
    // if not append the message to full_messages and increase the counter to check the next line
    let nextStart = new Date(`1970-01-01T${start[i + 1]}Z`);
    let currentStop = new Date(`1970-01-01T${stop[i]}Z`);
    let diff = nextStart.getTime() - currentStop.getTime();
    if (diff > pause) {
      full_messages = full_messages.concat(part_messages[i]);
      i++;
    } else {
      // if the start and stop times are the same initialise an empty string and
      // loop over messages from that point and append them to the string until the
      // start and stop times are no longer consistent
      let sentence = "";
      while (diff <= pause && i + 1 < part_messages.length - 2) {
        sentence = sentence + part_messages[i] + " ";
        i++;
        nextStart = new Date(`1970-01-01T${start[i + 1]}Z`);
        currentStop = new Date(`1970-01-01T${stop[i]}Z`);
        diff = nextStart.getTime() - currentStop.getTime();
      }
      sentence = sentence + part_messages[i];
      i++;
      full_messages = full_messages.concat(sentence);
    }
  }
  // check the last 2 elements of the partial message list and append them to full_messages
  if (start[start.length - 1] === stop[stop.length - 2]) {
    let end =
      part_messages[part_messages.length - 2] +
      " " +
      part_messages[part_messages.length - 1];
    if (stop[stop.length - 2] === stop[stop.length - 3]) {
      full_messages[full_messages.length - 1] =
        full_messages[full_messages.length - 1] + " " + end;
    } else {
      full_messages = full_messages.concat(end);
    }
  } else if (stop[stop.length - 2] === stop[stop.length - 3]) {
    full_messages[full_messages.length - 1] =
      full_messages[full_messages.length - 1] +
      " " +
      part_messages[part_messages.length - 2];
    full_messages = full_messages.concat(
      part_messages[part_messages.length - 1]
    );
  } else {
    full_messages = full_messages.concat(
      part_messages[part_messages.length - 2]
    );
    full_messages = full_messages.concat(
      part_messages[part_messages.length - 1]
    );
  }
  return "<p>" + full_messages.join("</p><p>") + "</p>";
}


/**
 * 
 * @function formatVtt
 * @param {String} vtt contents of the vtt file
 * @returns {String} HTML text containing the transcript formatted into paras
 */

function formatVtt(vtt) {
  let text = "";
  try {
    let dict = createVttDictionary(vtt);

    if (dict["messages"].length === 0) {
      text = `<h3>Error</h3> <p>No captions detected</p>`;
    } else { 
      text = formatText(dict);
    }
  } catch (e) {
    console.error(e);
  }
  return text;
}


module.exports = {
	formatVtt
}